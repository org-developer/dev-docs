---
id: database
sidebar_position: 2
---

# Database

## Index

- 데이터베이스 분야에 있어서 테이블에 대한 동작의 속도를 높여주는 자료 구조
- 인덱스는 테이블 내의 1개의 컬럼, 혹은 여러 개의 컬럼을 이용하여 생성될 수 있다
- 고속의 검색 동작뿐만 아니라 레코드 접근과 관련 효율적인 순서 매김 동작에 대한 기초를 제공한다
- 인덱스를 저장하는 데 필요한 디스크 공간은 보통 테이블을 저장하는 데 필요한 디스크 공간보다 작다
  - 이유: 보통 인덱스는 키-필드만 갖고 있고, 테이블의 다른 세부 항목들은 갖고 있지 않기 때문이다
- 인덱스는 고유 제약 조건을 실현하기 위해서도 사용된다 (Unique Key)
  - 고유 인덱스는 중복된 항목이 등록되는 것을 금지하기 때문에 인덱스의 대상인 테이블에서 고유성이 보장된다

### Clustered Index

- 인덱스 키의 순서에 따라 데이터가 정렬되어 저장되는 방식
- 데이터가 순서대로 저장되어 있어 인덱스를 검색하지 않아도 원하는 데이터를 빠르게 찾을 수 있다
- 데이터 삽입/삭제시 순서를 유지하기 위해 데이터 재정렬을 해야 한다
- 한 개의 릴레이션에 하나의 인덱스만 생성 가능

### Non Clustered Index

- 인덱스의 키 값만 정렬되어 있을 뿐 실제 데이터는 정렬되지 않는 방식
- 데이터를 검색하기 위해서는 먼저 인덱스를 검색하여 실제 데이터 위치를 확인해야 한다
- 한 개의 릴레이션에 여러개의 인덱스를 만들 수 있다
- Unique Key 생성시 해당

### Index 자료구조

#### Hash Table

- key, value 로 데이터를 저장하는 자료구조
- 빠른 검색이 필요할 때 유용
- Hash Table 은 key 로 빠르게 자료를 찾을때 유용하기 때문에 db 에서 검색(크다, 작다 등)을 위해 사용하기에는 적합하지 않다

#### B+ Tree

- DB 인덱스를 위해 자식 노드가 2개 이상인 B-Tree 를 개선시킨 자료구조이다.
- 데이터 노드만 인덱스와 함께 데이터(value)를 가지고 있고, 인덱스 노드들은 데이터를 위한 인덱스(key)만 가지고 있다
- 데이터 노드들은 LinkedList 로 연결되어 있다
- 데이터 노드 크기는 인덱스 노드 크기와 같지 않아도 된다

![cs-b+tree.png](/img/cs/cs-b+tree.png)


## Transaction

### Isolation Level

- READ UNCOMMITTED
  - 어떤 트랜잭션의 변경 내용이 COMMIT 이냐 ROLLBACK 이냐 상관없이 다른 트랜잭션에서 조회할 수 있다
  - Dirty Read 가 발생할 수 있다
- READ COMMITTED
  - 어떤 트랜잭션의 변경 내용이 COMMIT 이 되어야만 다른 트랜잭션에서 조회할 수 있다
- REPETABLE READ
  - 트랜잭션이 시작되기 전에 커밋된 내용에 대해서만 조회가 가능하다
  - MySQL의 기본 설정
- SERIALIZABLE
  - 읽기 작업에서도 공유 잠금을 설정하게 되고, 동시에 다른 트랜잭션에서 이 레코드를 변경하지 못한다
  - 동시처리 능력이 다른 격리수준보다 떨어지고, 성능저하가 발생하게 된다